package Solved_101_125;

import java.math.BigInteger;

/**
 * Optimum polynomial
 * Problem 101
 * 
 * If we are presented with the first k terms of a sequence it is impossible to
 * say with certainty the value of the next term, as there are infinitely many
 * polynomial functions that can model the sequence.
 * 
 * As an example, let us consider the sequence of cube numbers. This is defined
 * by the generating function, un = n^3: 1, 8, 27, 64, 125, 216, ...
 * 
 * Suppose we were only given the first two terms of this sequence. Working on
 * the principle that "simple is best" we should assume a linear relationship
 * and predict the next term to be 15 (common difference 7). Even if we were
 * presented with the first three terms, by the same principle of simplicity, a
 * quadratic relationship should be assumed.
 * 
 * We shall define OP(k, n) to be the nth term of the optimum polynomial
 * generating function for the first k terms of a sequence. It should be clear
 * that OP(k, n) will accurately generate the terms of the sequence for n <= k,
 * and potentially the first incorrect term (FIT) will be OP(k, k+1); in which
 * case we shall call it a bad OP (BOP).
 * 
 * As a basis, if we were only given the first term of sequence, it would be
 * most sensible to assume constancy; that is, for n >= 2, OP(1, n) = u1.
 * 
 * Hence we obtain the following OPs for the cubic sequence:
 * OP(1, n) = 1 1,			1, 1, 1, ...
 * OP(2, n) = 7n-6			1, 8, 15, ...
 * OP(3, n) = 6n^2-11n+6	1, 8, 27, 58, ...
 * OP(4, n) = n^3			1, 8, 27, 64, 125, ...
 * 
 * Clearly no BOPs exist for k >= 4.
 * 
 * By considering the sum of FITs generated by the BOPs (indicated in red
 * above), we obtain 1 + 15 + 58 = 74.
 * 
 * Consider the following tenth degree polynomial generating function:
 * 
 * un = 1 - n + n2 - n3 + n4 - n5 + n6 - n7 + n8 - n9 + n10
 * 
 * Find the sum of FITs for the BOPs.
 */
public class PE101_Optimum_polynomial {
	private static final BigInteger MINUS_ONE = new BigInteger("-1");

	public static void main(String[] args) {
		long start = System.nanoTime();

		long result = 0;

		for (int i = 1; i < 11; i++) {
			BigInteger[] answers = new BigInteger[i];

			for (int j = 0; j < i; j++) {
				answers[j] = get(j + 1);
			}

			BigInteger[] values = getABCD(answers);
			result += get(i + 1, values).longValue();
		}

		long end = System.nanoTime();
		long runtime = end - start;
		System.out.println(result);
		System.out.println("Runtime: " + runtime / 1000000 + "ms (" + runtime
				+ "ns)");
	}

	private static BigInteger get(int term) {
		return new BigInteger(String.valueOf((long) (1 - term
				+ Math.pow(term, 2) - Math.pow(term, 3) + Math.pow(term, 4)
				- Math.pow(term, 5) + Math.pow(term, 6) - Math.pow(term, 7)
				+ Math.pow(term, 8) - Math.pow(term, 9) + Math.pow(term, 10))));
	}

	private static BigInteger get(int term, BigInteger... values) {
		BigInteger result = BigInteger.ZERO;

		for (int i = 0; i < values.length; i++) {
			result = result.add(values[i].multiply(new BigInteger(String
					.valueOf(term)).pow(values.length - i - 1)));
		}

		return result;
	}

	private static BigInteger[] getABCD(BigInteger... answers) {
		BigInteger[][] values = new BigInteger[answers.length][];
		BigInteger[] tmp = new BigInteger[answers.length];

		for (int i = 0; i < values.length; i++) {
			values[i] = tmp.clone();
		}

		for (int i = 0; i < values.length; i++) {
			for (int j = 0; j < values[i].length; j++) {
				values[i][j] = new BigInteger(String.valueOf(i + 1))
				.pow(values[j].length - j - 1);
			}
		}

		for (int i = 0; i < values.length; i++) {
			for (int j = i + 1; j < values.length; j++) {
				BigInteger mult = values[j][i].divide(values[i][i]).multiply(
						MINUS_ONE);

				if ((mult.multiply(values[i][i]).compareTo(
						values[j][i].multiply(MINUS_ONE)) == 0) ^ true) {
					mult = values[j][i].multiply(MINUS_ONE);

					for (int k = i; k < values[i].length; k++) {
						values[j][k] = values[j][k].multiply(values[i][i]);
					}

					answers[j] = answers[j].multiply(values[i][i]);
				}

				answers[j] = answers[j].add(answers[i].multiply(mult));

				for (int k = i; k < values[j].length; k++) {
					values[j][k] = values[j][k]
							.add(values[i][k].multiply(mult));
				}
			}
		}

		BigInteger[] result = new BigInteger[answers.length];

		for (int i = result.length - 1; i >= 0; i--) {
			if (i == result.length - 1) {
				result[i] = (values[i][result.length - 1]
						.equals(BigInteger.ZERO)) ? BigInteger.ZERO
								: answers[i].divide(values[i][result.length - 1]);
			} else {
				result[i] = answers[i];

				for (int j = values.length - 1; j > i; j--) {
					result[i] = result[i].add(values[i][j].multiply(result[j])
							.multiply(MINUS_ONE));
				}

				result[i] = (values[i][i].equals(BigInteger.ZERO)) ? BigInteger.ZERO
						: result[i].divide(values[i][i]);
			}
		}

		return result;
	}
}
